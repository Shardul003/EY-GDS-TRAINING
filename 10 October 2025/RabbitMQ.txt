What is RabbitMQ?
Rabbit MQ software that helps different parts of a system communicate with each other asynchronously (without waiting for an immediate response).
RabbitMQ acts like a middleman between systems or services. It receives messages from one application (the producer) and delivers them to another (the consumer).
1. No direct dependency between services. 
2. Many producers/consumers can connect.
3. Ensures message delivery with acknowledgments and retries.
4. Supports multiple protocols like AMQP, MQTT, STOMP.
Working
1. Producer	Sends messages to RabbitMQ
2. Queue	Stores messages until they are processed
3. Consumer	Receives and processes messages
4. Exchange	Routes messages to appropriate queues based on rules
5. Binding	Defines the connection between an exchange and a queue

ADVANTAGES 
1. High Concurrency handling.
2. Fault Tolerance.
3. Lightweight process management.

Why Use a Queue in Real time systems.
Consumers (like analytics processors, databases, or dashboards) might not process data at the same rate.
A queue allows each side to work independently.
If one goes down, the other still works.
A traffic monitoring system collects vehicle speed data (producer) and updates the dashboard (consumer).
If the dashboard slows down, the queue ensures data isn’t lost.

2. Load Balancing - Queues distribute tasks evenly among multiple consumers. Helps prevent any single consumer from getting overloaded.
In a ride-hailing app, trip requests go into a queue, and multiple dispatch servers read from it simultaneously.

3. Fault Tolerance & Reliability
If a consumer crashes, the queue can retain unprocessed messages until it comes back online.
Ensures no data loss and guaranteed message delivery.

4. Rate Control (Buffering)
In real-time systems, data can arrive faster than it’s processed.
A queue smooths out the spikes in traffic, preventing overloads.


Use Cases of Queue:
1. Real-Time Vehicle Tracking System
When GPS devices on thousands of vehicles send location data every few seconds, a message queue collects all those updates.
Each vehicle → sends location data → queue (RabbitMQ / Kafka)
A Consumer service read the data in real time and processes data. The processed data then updates live maps & alerts.

It prevents data loss and handles bursts of incoming location data smoothly.

2. Stock Market & Trading Systems
Stock exchanges produce millions of price updates per second.
A queue distributes those updates to analytics engines or trading bots.
Stock Exchange push sends stock updates into queue.
Consumers  read,analyze and then  execute trades or display real-time charts


3. Healthcare Monitoring 
IoT device send reading to queue → health monitoring system
Alerts trigger if abnormal data appears

Queues guarantee reliable delivery of critical health data even if the backend is temporarily down.


4. E-commerce Order Processing
During big sales, thousands of orders are placed simultaneously.
User places order → order event sent to queue
Payment, inventory, and shipping services consume messages at their own pace
Prevents system overload and enables asynchronous workflows (e.g., order confirmation first, invoice later).

5. Chat or Messaging Applications
Every message sent by users is stored in a queue before delivery.
Sender → sends message → queue → receiver’s device
Ensures messages aren’t lost if one user goes offline temporarily.


